# 회의의 수 N과, N개의 줄에 걸쳐 각 회의의 시작 시간과 끝나는 시간이 주어짐
# 입력으로 주어지는 회의의 시작 시간과 끝나는 시간에는 어떠한 가정도 부여되어 있지 않음
# 회의를 잘 배치해서 가장 많이 배치했을 때 그 수는?

# 접근 1
# 1번째 자리 배치 방법: 시작 시간 순으로 정렬하고, 그 중 끝나는 시간이 가장 짧은 것을 고르기
# 2번째 자리 배치 방법: 이전에 끝난 시간 이후로 가장 빠른 시간을 고른 뒤, 그 중 끝나는 시간이 가장 짧은 것을 고르기

# 반례
# 시작 시간은 0인데 끝나는 시간이 1억일 수인 케이스 존재 가능. 이러면 시작 시간 1에 끝나는 시간 1 같은 유형의 케이스들 때문에 안 됨

# 접근 2
# 1번째 자리 배치 방법: 끝나는 시간이 가장 빠른 애(절대치) 선택
# 1번째 자리 배치 방법: 1번쨰 끝 시간 이후로 끝나는 시간이 가장 빠른 애(절대치) 선택

# 반례
# (끝나는 시간이 가장 빠르지 않은 애를 골라도 최적의 경우를 고를 수 있을까? 없는듯?)
# -> 끝나는 시간이 같은 회의가 여러 개 존재하는 경우, 시작 시간이 더 빠른 걸 골라야함
# 그래야 시작 시간이 더 느린 회의도 추가적으로 고를 수 있음


def solution(n, times):
    ans = 0

    # 끝나는 시간 기준 정렬
    times.sort(key=lambda x: (x[1], x[0]))  # O(nlogn)

    prev_end = None
    for i, (start, end) in enumerate(times):  # O(n)
        # 이전에 끝난 회의 시간보다 현재 선택할 회의의 시작 시간이 빠를 수 없음
        if prev_end and start < prev_end:
            continue
        # 회의실 배정 후, 지금 배정한 회의실의 종료 시간 저장
        ans += 1
        prev_end = end

    return ans


n = int(input())
times = [list(map(int, input().split())) for _ in range(n)]
ans = solution(n, times)
print(ans)
