# # 두 큐의 각 큐 원소의 합이 같게 만드는 (pop/insert) 작업의 최소 횟수
# from collections import deque
# from functools import lru_cache


# def dfs(q1, q2, ops, sq1, sq2):
#     global min_ops, memo
#     if sq1 == sq2:
#         memo[tuple(q1)] = 0
#         memo[tuple(q2)] = 0
#         min_ops = min(min_ops, ops)
#         return
#     if len(q1) == 0:
#         memo[tuple(q1)] = 0
#         memo[tuple(q2)] = 0
#         return
#     if len(q2) == 0:
#         memo[tuple(q1)] = 0
#         memo[tuple(q2)] = 0
#         return

#     if tuple(q1) in memo or tuple(q2) in memo:
#         return

#     # backtracking
#     # 연산 1번
#     if sq1 > sq2:
#         q1_elem = q1.popleft()
#         q2.append(q1_elem)
#         dfs(q1, q2, ops+1, sq1-q1_elem, sq2+q1_elem)
#         # q1.append(q1_elem)
#         # q2.pop()
#     else:
#         q2_elem = q2.popleft()
#         q1.append(q2_elem)
#         dfs(q1, q2, ops+1, sq1+q2_elem, sq2-q2_elem)
#         # q2.append(q2_elem)
#         # q1.pop()


# def solution(queue1, queue2):
#     global min_ops, memo
#     q1 = deque(queue1)
#     q2 = deque(queue2)

#     min_ops = float('inf')
#     memo = dict()

#     sq1 = sum(q1)
#     sq2 = sum(q2)
#     dfs(q1, q2, 0, sq1, sq2)

#     if min_ops == float('inf'):
#         return -1
#     else:
#         return min_ops


# q1 = [3, 2, 7, 2]
# q2 = [4, 6, 5, 1]
# q1 = [1, 1]
# q2 = [1, 5]
# q1 = [1, 2, 1, 2]
# q2 = [1, 10, 1, 2]
# res = solution(q1, q2)
# print(res)
